<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>Pacman3D</title>
<style>
    html, body {
        margin: 0;  /* Make sure that there is no margin around the canvas */
        overflow: hidden;  /* Make sure we don't get scroll bars. */
    }
    canvas {
        display: block; /* The default display, inline, would add a small margin below the canvas */
    }

    #info {
        position: absolute;
        top: 0px; width: 100%;
        z-index: 100;
		width: 180px;
		padding: 10px;
		border: 5px solid black;
		margin: 0;
		background-color: lightblue;
    }
</style>
<script src="js/pacmanModel.js"></script>
<script src="js/basicModels.js"></script>
<script src="js/three.js"></script>
<script src="js/map.js"></script>
<script src="js/Water.js"></script>
<script src="js/Ghost.js"></script>
<script src="js/threex.keyboardstate.js"></script>
<script src="js/Pathfinder.js"></script>
<script src="js/Detector.js"></script>
<!-- Window Stuff -->
<!-- Post Processing and Shaders -->
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/FXAAShader.js"></script>
<script>

    "use strict";
    //import * as THREE from "js/three.js"

    var scene, camera, renderer, container;  // Three.js rendering basics.
  	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;	//Screen stuff
  	var frameNumber = 0;

  	var pause = false;	//Controls whether or not animations are running
  	var win = false;	//Controls whether or not the player has won
  	var loss = false;	//Controls whether or not the player has lost

    //Mouse Controls
  	var mouseY = 0;
    var mouseDown = false;
    var maxTilt = 1.5;
    var minTilt = 0;

    var canvas;  // The canvas on which the renderer will draw.
                 // This will be created by the renderer, and it will
                 // be added to the body of the page.  When the window is
                 // resized, the canvas will also be resized so that it
                 // always fills the window.

    var player;            //Pacman+Camera
    var pacman;     //Objects

    var water, trampolines;

    var pSign = 1;      //Direction change parameter for pacman's mouth

    var zoom = 1;          //For testing

    if(zoom == 1){
        var camAngle = 0.2027;    //tan(1/5)
        var camDist = 50*zoom;
    }
    else{
        var camAngle = 0.6841;  //tan(3/5)
        var camDist = 60*zoom;
    }

    var velocity = 2.5;
    var ghostVelocity = 2;
    var angularVelocity = Math.PI * (3/4);
    var gravity = 0.08;
    var yVelocity = 0;

    var keyboard = new THREEx.KeyboardState();      //This is a really cool library for keyboard events

    var forwardGo = true;       //Is pacman allowed to move forward/backward?
    var backwardGo = true;

    //Collideables
    var hedgesS, hedgesN, pelletsS, pelletsN;
    var activePowerup;
    var powerType = "cherry";
    var powerOn = false;
    var ghosts = [];
    var ghostCols = ["red","green","cyan","blue","purple","orange","pink"];
    //Keep track of the next node each ghost must attend
    var nextMove = [];
    //Paths
    var paths = [];
    var ghostX = [-3,-9,-6,-22,-25,-10,-19];
    var ghostZ = [13,-1,5,11,-1,5,8];
    var ghostHeight = 6;

    //GUI
    var score = 0;
  	var lives = 3;
  	var pelletNum, pelletStartNum;
  	var graphicsSetting = "Low"

  	//Minimap
  	var mapCamera, mapWidth = 400, mapHeight = 400; // w/h should match div dimensions

  	//Clear function
  	THREE.Object3D.prototype.clear = function(){
  		var children = this.children;
  		for(var i = children.length-1;i>=0;i--){
  			var child = children[i];
  			child.clear();
  			this.remove(child);
  		};
  	};


    function createWorld() {
        //Camera and Scene
        renderer.setClearColor("black"); // Background color for scene.
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(30, canvas.width / canvas.height, 0.1, 2000 * zoom);


        //Ambient Light
        scene.add(new THREE.AmbientLight(0x101010));

        //Camera Position
        camera.position.x = camDist * Math.cos(camAngle);
        camera.position.y = camDist * Math.sin(camAngle);

        //Make Skybox
        var sky = makeSkybox();
        scene.add(sky);

        //Camera Light
        var light = new THREE.PointLight();
        camera.add(light);

        //Sun
        var sun = new THREE.DirectionalLight(0xffffff, 0.5);
        scene.add(sun);

        //Make Pacman
        pacman = makePacman();

        //Adjust camera angle
        camera.lookAt(pacman.position);

        //Make player
        player = new THREE.Group();
        player.add(pacman);
        player.add(camera);

    		//Minimap Camera
        var wZoom = 2.4;
        var hZoom = 1.2;
    		mapCamera = new THREE.OrthographicCamera(
    			window.innerWidth / -wZoom,		// Left
    			window.innerWidth / wZoom,		// Right
    			window.innerHeight / hZoom,		// Top
    			window.innerHeight / -hZoom,	// Bottom
    			-5000,            			// Near
    			10000 );           			// Far
    		mapCamera.up = new THREE.Vector3(-1,0,0);
        var mapCameraX = -12.5*voxel;
        var mapCameraY = voxel;
        var mapCameraZ = 0.5*voxel;
        mapCamera.position.set(mapCameraX,mapCameraY,mapCameraZ);
    		mapCamera.lookAt( new THREE.Vector3(mapCameraX,-1,mapCameraZ) );

        //Renderer Stuff
        if ( Detector.webgl )
        	renderer = new THREE.WebGLRenderer( {antialias:true} );
        else
        	renderer = new THREE.CanvasRenderer();
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container = document.getElementById( 'ThreeJS' );
        container.appendChild( renderer.domElement );

		    //Make Floor
        var sFloor = makeFloor();
        var nFloor = makeNorthFloor();

        //Make hedges
        hedgesS = makeHedges();
        hedgesN = makeNorthHedges();

        //Make Trampolines
        trampolines = makeTrampolines();

        //Make Pellet
        pelletsS = makeSouthPellets();
        pelletsN = makeNorthPellets();
        pelletNum = 0;                              //Count number of pellets
        for(var i=0;i<pelletsS.children.length;i++){
            pelletNum++;
        }
        for(var i=0;i<pelletsN.children.length;i++){
            pelletNum++;
        }
		    pelletStartNum = pelletNum;

        //Make Ghosts
      	for (var i=0;i<ghostCols.length;i++){
      		var ghost = makeGhost(ghostCols[i],ghostCols[i])
      		ghost.scale.set(10,10,10);
      		var thisPath = findPath(ghostCols[i]);
      		paths.push(thisPath);
      		ghost.position.set(ghostX[i]*voxel,ghostHeight,ghostZ[i]*voxel)
      		ghosts.push(ghost);
      		nextMove.push(1);
      		scene.add(ghost);
      	}

        //Make Water
        water = makeWater(sun);

        //Fill Scene
	       scene.add(mapCamera);
        scene.add(player);
        scene.add(sFloor);
        scene.add(nFloor);
        scene.add(hedgesN);
        scene.add(hedgesS);
        scene.add(trampolines);
        scene.add(pelletsN);
        scene.add(pelletsS);
        scene.add(water);

        //Renderer stuff
      	renderer.setSize( window.innerWidth, window.innerHeight );
      	renderer.setClearColor( 0x000000, 1 );
      	renderer.autoClear = false;

      	//Create start message
      	alert("\"Dear Pacman,\n\nAn attempt on your life has left you scarred and deformed. Your home has been assaulted and your family kidnapped. You have been captured by evil ghosts and have been imprisoned in their maze. Only by collecting all the pellets can you hope to escape and rescue your family.\"\n\nTo move, use the W,A,S and D keys\nTo jump, press Spacebar\nTo change the camera angle, use the Arrow Keys or click on the screen\nTo pause, press P\nTo toggle graphics, press G\n\nCollect all the pellets to win, but try to avoid the ghosts and the river, all of which will kill you. Collect cherries to increase your life.\n\nGood luck!");

    }

	//
	//		Collisions
	//
	//
	//
	//
	//
	//

    //Return bounding box from object
    function makeBB(obj){
      var bb = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());  //New box
      bb.setFromObject(obj);  //Give it object bounds
      return bb;
    }

	//Create an array of bounding boxes from a group
    function makeBBs(group){
        var bbs = [];
        for (var i=0;i<group.children.length;i++){
            var bb = makeBB(group.children[i]);   //Make a bounding box from every child of group
            bbs.push(bb);
        }
        return bbs;
    }

	//Check if Pacman is colliding with a ghost
	function ghostCollision(){
		var pacmanBB = makeBB(pacman);
		for (var i=0;i<ghosts.length;i++){
			var ghostBB = makeBB(ghosts[i])
			if(pacmanBB.intersectsBox(ghostBB)){
				lives--;
				resetPosition();
				updateScore();
				resetGhosts();
				return;
			}
		}
	}

	//Check if colliding with pellet
    function eat(){
        var pacmanBB = makeBB(pacman);  //Pacman bounding box

        //South
        for(var i=0;i<pelletsS.children.length;i++){
            var pBB = makeBB(pelletsS.children[i]);   //Make bounding box for pellet
            if(pacmanBB.intersectsBox(pBB)){          //If pacman intersects a pellet
                scene.remove(pelletsS.children[i]);     //Remove pellet from scene
                pelletsS.remove(pelletsS.children[i]);  //Remove pellet from south maze
                score++;  //Increase score
				pelletNum--;	//Decrease remaining pellets
				updateScore();
                return;
            }
        }
        //North
        for(var i=0;i<pelletsN.children.length;i++){
            var pBB = makeBB(pelletsN.children[i]); //Make bounding box for pellet
            if(pacmanBB.intersectsBox(pBB)){        //If pacman intersects a pellet
                scene.remove(pelletsN.children[i]);     //Remove pellet from scene
                pelletsN.remove(pelletsN.children[i]); //Remove pellet from south maze
                score++;    //Increase score
				pelletNum--;	//Decrease remaining pellets
				updateScore();
                return;
            }
        }

    }

	//Check if colliding with an obstacle
    function collideTest(obstacles){
      var pacmanBB = makeBB(pacman);
      for(var i=0;i<obstacles.length;i++){
          if(pacmanBB.intersectsBox(obstacles[i])){
              return true;
          }
      }

     return false;
    }

	//Check if colliding with powerup
	function collidesWithPowerup(){
		var pacmanBB = makeBB(pacman);
		var objectBB = makeBB(activePowerup);
		if(pacmanBB.intersectsBox(objectBB)){
			if(powerType=="cherry"){
				lives++;
				updateScore();
			}
			scene.remove(activePowerup);
			powerOn = false;
		}
	}

	//
	//		UI
	//
	//
	//
	//
	//
	//

	//Toggle graphics
	function toggleGraphics(){
		if(graphicsSetting=="Low"){
			graphicsSetting = "High";
		}
		else{
			graphicsSetting = "Low";
		}
		updateScore();
	}

	//Update the score
	function updateScore(){
		document.getElementById("score").innerHTML = score;
		document.getElementById("pelletNum").innerHTML = pelletNum;
		document.getElementById("lives").innerHTML = lives;
		document.getElementById("graphics").innerHTML = graphicsSetting;
		//Lose
		if(lives == 0){
			loss = true;
			alert("Oh no! You have lost!\nPress 'R' to try again...");
		}
		//Win
		if(score == pelletStartNum){
			win = true;
			alert("Congratulations! You have won!\nPress 'R' to play again...");
		}
	}

    //
	//		Rendering
	//
	//
	//
	//
	//
	//

    function render() {
		var w = window.innerWidth;
		var h = window.innerHeight;

		// setViewport parameters:
		//  lower_left_x, lower_left_y, viewport_width, viewport_height
		renderer.setViewport( 0, 0, w, h );
		renderer.clear();

		//Scene
        renderer.render(scene, camera);
		//Minimap
		renderer.setViewport( 10, h - mapHeight - 10, mapWidth, mapHeight );
		renderer.render( scene, mapCamera );
    }

    //
	//		Animation
	//
	//
	//
	//
	//
	//

	//Animate Pacman
    function animatePacman(pacman){
        var topHalf = pacman.children[1];                                       //Get top half of mouth
        if(topHalf.rotation.z > pacmanRotation|| topHalf.rotation.z < 0){       //Change rotation if beyond mouth rotation
            pSign = -1*pSign;
        }

        topHalf.rotation.z = topHalf.rotation.z + pSign*0.05;
        topHalf.position.y = pacmanRadius*Math.sin(-1*topHalf.rotation.z);                    //Move up
        topHalf.position.x = pacmanRadius - pacmanRadius*Math.cos(-1*topHalf.rotation.z);     //Adjust position for rotation
    }

	//Animate the pellets
    function animatePellets(){
        var pelletIncrement = 0.1;      //Size of pellet rotation
        //South pellets
        for(var i=0;i<pelletsS.children.length;i++){
            pelletsS.children[i].rotateY(pelletIncrement);
            pelletsS.children[i].rotateX(pelletIncrement/2);
            pelletsS.children[i].rotateZ(pelletIncrement/4);
        }
        //North Pellets
        for(var i=0;i<pelletsN.children.length;i++){
            pelletsN.children[i].rotateY(pelletIncrement);
            pelletsN.children[i].rotateX(pelletIncrement/2);
            pelletsN.children[i].rotateZ(pelletIncrement/4);
        }
    }

    function updateForFrame() {
		if(win == true){
			//Restart
			if ( keyboard.pressed("r")) {
				win = false;
				restart();
			}
			return;
		}

		if(loss == true){
			//Restart
			if ( keyboard.pressed("r")) {
				loss = false;
				restart();
			}
			return;
		}

		if(pause){
			//Unpause
			keyboard.domElement.addEventListener('keydown', function(event){
				if (event.repeat && keyboard.eventMatches(event, 'p')) {
					return;
				}
				if ( keyboard.eventMatches(event, 'p') ){
					pause = false;
				}
			})
			return;
		}

		if(onWater()){
			resetPosition();
			lives--;
			updateScore();
		}

        var dt = clock.getDelta();  // time since last update, in milliseconds
        animatePacman(pacman);
		if(graphicsSetting=="High"){
			animatePellets();
		}

		//Add powerups
		if(frameNumber % 1000 == 0){
			if(powerOn){
				scene.remove(activePowerup);
			}
			activePowerup = makeCherry();
			powerType = "cherry";
			activePowerup = randomPosition(activePowerup);
			scene.add(activePowerup);
			powerOn = true;
		}

        //Movement Increments
        var moveIncrement = velocity;                  // 80 units per second
        var angleIncrement = angularVelocity * dt;   // 3*pi/4 radians per second
		var groundTolerance = 0.1;	//Distance from ground
        if(player.position.y < groundTolerance){ //On ground
            player.position.y = 0;
            yVelocity = Math.max(0,yVelocity);
            var canJump = true;
        }
        else{
           yVelocity -= gravity //Fall
            var canJump = false;
        }

        var hedgeObstaclesS = makeBBs(hedgesS);
        var hedgeObstaclesN = makeBBs(hedgesN);
        var obstacles = hedgeObstaclesS.concat(hedgeObstaclesN);  //Make hedge bounding boxes

        eat();  //Check if pellets are to be eaten

		//Collide with powerup
		if(powerOn){
			collidesWithPowerup();
		}

		//Ghosts
		for (var i=0;i<ghosts.length;i++){
			animateGhost(ghosts[i]);
			nextMove[i] = moveToNextNode(ghosts[i],paths[i],nextMove[i]);
		}
		ghostCollision();

        //Jump
        if(keyboard.pressed("space") && canJump){
            yVelocity = 1.5;
        }

        //Trampoline Jump
        if(onTrampoline()){
          yVelocity = 6;
        }

        //Y Velocity
        player.translateY(yVelocity);

        var rebound = 1;  //For stopping movement

        //Translate
        if ( keyboard.pressed("W") && forwardGo) {
            player.translateX(-moveIncrement);
            if(collideTest(obstacles)){                 //If colliding, move backwards
              player.translateX(moveIncrement);
            }
        }
        if ( keyboard.pressed("S") && backwardGo) {
            player.translateX(moveIncrement);
            if(collideTest(obstacles)){       //If colliding, move forwards
              player.translateX(-rebound);
            }
        }

        //Rotate
        if ( keyboard.pressed("A") || keyboard.pressed("left") ) {
            player.rotateOnAxis(new THREE.Vector3(0, 1, 0), angleIncrement);
        }
        if ( keyboard.pressed("D") || keyboard.pressed("right") ) {
            player.rotateOnAxis(new THREE.Vector3(0, 1, 0), -angleIncrement);
        }

        //Camera move

		//Arrow keys
        if ( keyboard.pressed("up") && camAngle < maxTilt ) {
            camAngle += angleIncrement;
        }
        if ( keyboard.pressed("down") && camAngle >= minTilt) {
            camAngle -= angleIncrement;
        }
		//Mouse control
		var myMouseControl = mouseControl();
		if((camAngle < maxTilt && myMouseControl > 0) || (camAngle > minTilt && myMouseControl < 0)){
			camAngle += myMouseControl
		}

        //Reset position
        if( keyboard.pressed("o") ){
            resetPosition();
        }

		//Pause
		keyboard.domElement.addEventListener('keydown', function(event){
			if (event.repeat && keyboard.eventMatches(event, 'p')) {
				return;
			}
			if ( keyboard.eventMatches(event, 'p') ){
				pause = true;
			}
		})

        //Rotate camera
        camera.position.x = camDist*Math.cos(camAngle);
        camera.position.y = camDist*Math.sin(camAngle);
        camera.lookAt( pacman.position );

        //Animate water
		if(graphicsSetting=="High"){
			water.material.uniforms.time.value += 1.0 / 100.0;
		}

		//Auto-Win
		if ( keyboard.pressed("l")) {
            removePellets();
			score = pelletStartNum;
			pelletNum = 0;
			win = true;
			updateScore();
        }

		//Toggle grahics
		keyboard.domElement.addEventListener('keydown', function(event){
			if (event.repeat && keyboard.eventMatches(event, 'g')) {
				return;
			}
			if ( keyboard.eventMatches(event, 'g') ){
				toggleGraphics();
			}
		})

		//render();
    }

	//
	//		World
	//
	//
	//
	//
	//
	//

	//Restart Game
	function restart(){
		resetPosition();			//Reset player position
		score = 0;					//Reset score
		pelletNum = pelletStartNum;	//Reset pellets to go
		lives = 3;					//Reset lives
		updateScore();
		//Remove current pellets
		removePellets();
		//Add new pellets
		pelletsS = makeSouthPellets();
        pelletsN = makeNorthPellets();
		scene.add(pelletsS);
		scene.add(pelletsN);
		//Reset ghosts
		resetGhosts();

		render();
	}

	//Reset ghosts
	function resetGhosts(){
		for (var i=0;i<ghosts.length;i++){
			ghosts[i].position.set(ghostX[i]*voxel,ghostHeight,ghostZ[i]*voxel);	//Reset to start position
			nextMove[i] = 1;		//Reset their next move
		}
	}

	//Reset Player position
	function resetPosition(){
		player.position.set(0,0,0);
		player.rotation.set(0,0,0);
	}

	//Remove all pellets
	function removePellets(){
		//Remove current pellets
		pelletsN.clear();
		pelletsS.clear();
		scene.remove(pelletsS);
		scene.remove(pelletsN);
	}

	//Check if on a trampoline. Returns true if on trampoline, false otherwise
    function onTrampoline(){
	  //Get player positions
	  var x = player.position.x;
	  var y = player.position.y-5;
	  var z = player.position.z;
	  var jumpDist = 10;    //Horizontal radius of trampoline jump area
	  var jumpDistY = 1;    //Vertical length of trampoline jump area
	  for (var i=0;i<trampolines.children.length;i++){
		  //Get trampoline positions
		  var tz = trampolines.children[i].position.z;
		  var ty = trampolines.children[i].position.y;
		  var tx = trampolines.children[i].position.x;
		  if(Math.abs(x-tx)<jumpDist && Math.abs(z-tz)<jumpDist && Math.abs(y-ty)<jumpDistY){ //Pacman is within jump volume
			return true;
		  }
	  }
	  return false;
    }

	//Check if on water. Returns true if on water, false otherwise
	function onWater(){
		//Get player positions
		var x = player.position.x;
		var y = player.position.y-5;
		//Height off ground
		var groundTolerance = 0.2;
		//Water bounds
		var lowX = -10.5*voxel;
		var highX = -14.5*voxel;
		if(x>highX && x<lowX && y<groundTolerance){
			return true;
		}
		return false;
	}

	//Set an object's position to a random corner of the world
	function randomPosition(myObject){
		var myNodes = ["-25,13","-25,-12","0,13","0,-12","-6,11","-6,-10","-19,11","-19,-10"]
		var index = Math.floor(Math.random()*myNodes.length);
		var pos = myNodes[index];
		var tuple = pos.split(",");
		myObject.position.set(tuple[0]*voxel,5,tuple[1]*voxel);
		return myObject;
	}


	//
	//
	//		Pathfinding
	//
	//
	//
	//
	//
	//

  //Choose direction for a ghost
  function moveToNextNode(myGhost,pathObject,nextNode){
	//Get list of nodes for this ghost
	var xNode = pathObject.x;
	var zNode = pathObject.z;
	var offset = 2;	//how far away is acceptable to be at a node
	var x = myGhost.position.x;
	var z = myGhost.position.z;
	//Controls whether or not the ghost is on the right level horizontally or vertically as the node
	var horiz = false;
	var vert = false;
	//Check if ghost's position lines up with a node
	if(Math.abs(x-xNode[nextNode])<offset){
	  vert = true;
	}
	if(Math.abs(z-zNode[nextNode])<offset){
	  horiz = true;
	}
	//Ghost has reached node
	if(vert && horiz){
	  nextNode = (nextNode+1)%xNode.length;		//Next node in list
	  //Reset control variables
	  vert = false;
	  horiz = false;
	  //Recalculate whether or not the ghost is in line with their next node
	  if(Math.abs(x-xNode[nextNode])<offset){
		vert = true;
	  }
	  if(Math.abs(z-zNode[nextNode])<offset){
		horiz = true;
	  }
	}
	//Choose direction
	var direction = "up";
	if(!vert){
	  if(x<xNode[nextNode]){
		direction = "down";
	  }
	  else{
		direction = "up";
	  }
	}
	else if (!horiz) {
	  if(z<zNode[nextNode]){
		direction = "left";
	  }
	  else{
		direction = "right";
	  }
	}
	//Move Ghost
	moveGhost(myGhost,direction,ghostVelocity);
	return nextNode;
  }
  //Move 'myGhost' in the direction 'direction' at a speed of 'increment'
  function moveGhost(myGhost,direction,increment){
	//Rotate
	if(direction == "up"){
	  myGhost.rotation.set(0,-Math.PI/2,0);
	}
	else if(direction == "down"){
	  myGhost.rotation.set(0,Math.PI/2,0);
	}
	else if(direction == "left"){
	  myGhost.rotation.set(0,0,0);
	}
	else if(direction == "right"){
	  myGhost.rotation.set(0,Math.PI,0);
	}
	//Move
	myGhost.translateZ(increment);
  }

    //
    //		Mouse Controls
	//
	//
	//
	//
	//
	//



	//Actual function for mouse movement
	function mouseControl(){
		var mouseSpeed = (SCREEN_HEIGHT / 2 - mouseY) / 4000;
		var camAngle = mouseSpeed;
		if(mouseDown){
			return camAngle;
		}
		return 0;
	}






    /* Do texture stuff */
    function makeTexture(imageURL, material) {
        function callback() { // Function to react when image load is done.
            if (material) {
                material.map = texture;  // Add texture to material.
                material.needsUpdate = true;  // Required when material changes.
            }
            render();  // Render scene with texture that has just been loaded.
        }
        var texture = THREE.ImageUtils.loadTexture(imageURL, undefined, callback);
        return texture;
    }

    //--------------------------- animation support -----------------------------------

    var clock;  // Keeps track of elapsed time of animation.

    /**
     *  Update data for new frame, call render(), and arrange for the next call to this function.
     */
    function doFrame() {
		updateForFrame();
		frameNumber++;
        render();
        requestAnimationFrame(doFrame);
    }

    //----------------------- respond to window resizing -------------------------------

    /**
     * When the window is resized, we need to adjust the aspect ratio of the camera.
     * We also need to reset the size of the canvas that used by the renderer to
     * match the new size of the window.
     */
    function doResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix(); // Need to call this for the change in aspect to take effect.
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    //----------------------------------------------------------------------------------

    /**
     *  This init() function is called when by the onload event when the document has loaded.
     */
    function init() {
        try {
            try {
                renderer = new THREE.WebGLRenderer( {
                    antialias: true
                } );
            }
            catch (e) {
                document.body.innerHTML="<h3><b>Sorry, WebGL is required but is not available.</b><h3>";
                return;
            }
            canvas = renderer.domElement;  // The canvas was created by the renderer.
            renderer.setSize(window.innerWidth, window.innerHeight);  // match size of canvas to window
            window.addEventListener("resize", doResize, false);  // Set up handler for resize event
            document.body.appendChild(canvas);  // The canvas must be added to the body of the page.
			//Event Listeners
			document.addEventListener('mousemove', function(event) {
				mouseY = event.clientY;
			}, false);
			document.body.addEventListener("mousedown", function(event) {
				mouseDown = true
			}, false);
			document.body.addEventListener("mouseup", function(event) {
				mouseDown = false
			}, false);
            clock = new THREE.Clock(); // For keeping time during the animation.
            createWorld();
            requestAnimationFrame(doFrame);  // Start the animation.
        }
        catch (e) {
            document.body.innerHTML = "<h3><b>Sorry, an error occurred:<br>" + e + "</b></h3>";
        }
    }

</script>
</head>
<body onload="init()">
<div id="info">
<b>Score: </b><span id="score">0</span>
<br>
<b>Pellets Remaining: </b><span id="pelletNum">252</span>
<br>
<b>Lives: </b><span id="lives">3</span>
<br>
<b>Graphics: </b><span id="graphics">Low</span>
</div>
<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<div id="mapCanvas" style="position: absolute; left:100px; top:100px; width:400px; height:400px;"></div>
</body>
